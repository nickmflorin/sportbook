@use "sass:map";
@use "sass:color";
@use "throw";
@use "partials";

%icon-svg-base {
  max-height: 100%;
  max-width: 100%;
  vertical-align: 0;
  // For when the icon is a spinner and indicating loading state.
  animation-duration: 1s;
  padding: 0;
  align-items: center;
  -webkit-box-align: center;
  -webkit-box-pack: center;
  justify-content: center;
}

%svg-base {
  fill: currentcolor;

  path {
    color: inherit;
    fill: inherit;
  }
}

@mixin icon-size-classes($axis) {
  @each $size in map.keys(partials.$icon-sizes) {
    &.icon--size-#{$size} {
      @include partials.icon-sizing($size, $axis);
    }
  }
}

.icon {
  @extend %icon-svg-base;
  display: flex;
  flex-direction: column;

  // @layer {
  //   color: partials.get-color("gray", $shade: 7);
  // }

  @include partials.disabled {
    color: partials.$disabled-color;
  }

  > svg {
    @extend %icon-svg-base;
    @extend %svg-base;
    color: inherit;

    /*
    Background:
    ----------
    The FontAwesome icon configuration works as follows:

    (1) The FontAwesome pro script is loaded via a <Script />
    (2) The script looks for <i> tags with the proper icon class name (i.e. fa-chevron-up) and nests an <svg> tag inside
        of the <i> tag, with the same attributes as the <i> tag (i.e. class name, style, etc.)

    This is done so that FontAwesome can *only* load the necessary CSS and SVGs for the icons that are actually used in
    the application.  This also means that it will only load the necessary CSS and SVGs for the icons that are defined
    when the elements are first rendered.

    Problem:
    -------
    What is the problem with this?  The problem is that it prevents icons from changing after the first render,
    particularly as it relates to user interaction.  If a component uses two different icons, where the second icon may
    not be shown until after the first render when the user interacts with the component, not only will the second icon
    not be loaded by FontAwesome initially - or at all - but the <svg> class name will indicate the original icon that
    was rendered, even if the <i> class name changes.

    For example, if we consider a button that toggles the icon between "chevron-up" and "chevron-down" when it is
    clicked, the HTML structure will exhibit the following behavior:

    // Before User Interaction & Before Font Awesome Loads
    <button>
      <i class="fa fa-chevron-up" />
    </button>

    // Before User Interaction but After Font Awesome Loads
    <button>
      <i class="fa fa-chevron-up">
        <svg class="fa fa-chevron-up" /> // This is responsible for rendering the actual Icon.
      </i>
    </button>

    // After User Interaction and After Font Awesome Loads
    <button>
      <i class="fa fa-chevron-down">
        <svg class="fa fa-chevron-up" /> // This is responsible for rendering the actual Icon.
      </i>
    </button>

    Note how after the user clicks the button, the class on the <i> tags changes appropriately (this is because our
    Icon component is responsible for that class name,  based on the 'icon' prop).  However, the underlying svg class
    name does not change - this is because the svg is populated by FontAwesome when it first loads the script.  The
    resulting effect is that the actual icon that is rendered will not change - because the class on the <i> tag is only
    used by FontAwesome to define the class on the <svg> when it is initially rendered - but does not change the svg
    class name after the fact.

    Solution
    --------
    The solution to this problem is that when a component uses multiple icons and the icon may change after the first
    render, it has to render both of them - but apply "display: none" to the icon or icon(s) that are not currently
    being shown.  When the interaction occurs, such as a button click, the Icon component will then toggle which <i>
    element has the "display: none" style attribute.

    // Before User Interaction & Before Font Awesome Loads
    <button>
      <i class="fa fa-chevron-up" />
    </button>

    // Before User Interaction but After Font Awesome Loads
    <button>
      <i class="fa fa-chevron-up">
        <svg class="fa fa-chevron-up" />
      </i>
      <i class="fa fa-chevron-down" style="display: none;">
        <svg class="fa fa-chevron-down" style="display: none;" /> // Style attribute is copied to the nested svg.
      </i>
    </button>

    However, since FontAwesome will copy all of the attributes on the <i> element to the nested <svg> element, when we
    remove or add the "display: none" tag on the <i> element, it will not have the same effect on the nested <svg>.  To
    fix this, we need to add "!important" to the "display: inherit" style on the <svg> element - ensuring that when the
    <i> element is hidden or shown, the nested <svg> element will also be hidden or shown - and since the <svg> is
    rendered in the DOM (but just hidden), the icon will appropriately change after user interaction occurs.

    // After User Interaction and After Font Awesome Loads
    <button>
      <i class="fa fa-chevron-up" style="display: none;">
        // Display none is still not inlined, but the important flag overrides.
        <svg class="fa fa-chevron-up" />
      </i>
      <i class="fa fa-chevron-down">
        // Display none is still inlined, but the important flag overrides.
        <svg class="fa fa-chevron-down" style="display: none;"/>
      </i>
    </button>
    */
    display: inherit !important;
  }

  &--contain-square:not(&--contain-fit) {
    @include partials.icon-contain("square");
  }

  &--contain-fit:not(&--contain-square) {
    @include partials.icon-contain("fit");
  }

  &:not(&--contain-fit, &--contain-square) {
    @include partials.icon-contain(partials.$default-icon-size-contain);
  }

  &--axis-vertical:not(&--axis-horizontal) {
    @include icon-size-classes("vertical");
  }

  &--axis-horizontal:not(&--axis-vertical) {
    @include icon-size-classes("horizontal");
  }

  &:not(&--axis-horizontal, &--axis-vertical) {
    @include icon-size-classes(partials.$default-icon-size-axis);
  }
}
