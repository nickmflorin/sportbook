generator client {
  provider        = "prisma-client-js"
  previewFeatures = []
}

datasource db {
  provider = "postgresql"
  url      = env("MIGRATE_DATABASE_URL")
}

enum Gender {
  MALE
  FEMALE
  NON_BINARY
}

model User {
  id                   String                 @id @default(uuid()) @db.Uuid
  clerkId              String                 @unique
  firstName            String
  lastName             String
  profileImageUrl      String?
  gender               Gender                 @default(value: NON_BINARY)
  emailAddress         String
  createdAt            DateTime               @default(now())
  updatedAt            DateTime               @updatedAt
  org                  Org?                   @relation("orgUsers", fields: [orgId], references: [id])
  orgId                String?                @db.Uuid
  // Users are only created when Clerk data for the user exists - so a default value of "now" makes sense here.
  lastUpdatedFromClerk DateTime               @default(now())
  teams                TeamOnPlayers[]        @relation("teams")
  participatingLeagues LeagueOnParticipants[] @relation("participatingLeagues")
  createdLocations     Location[]             @relation("createdLocations")
  uploadedFiles        FileUpload[]           @relation("uploadedFiles")
}

model Org {
  id        String   @id @default(uuid()) @db.Uuid
  clerkId   String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  timezone  String?
  name      String?
  street1   String?
  street2   String?
  city      String?
  state     String?
  zip       String?
  users     User[]   @relation("orgUsers")
}

enum FileUploadEntity {
  LOCATION
  LEAGUE
  TEAM
}

enum FileType {
  IMAGE
}

// TODO: Use middleware to prevent mutation of existing FileUpload models (i.e. make it a readonly field).
model FileUpload {
  id          String           @id @default(uuid()) @db.Uuid
  createdAt   DateTime         @default(now())
  createdById String           @db.Uuid
  createdBy   User             @relation("uploadedFiles", fields: [createdById], references: [id])
  fileUrl     String
  fileType    FileType
  entityType  FileUploadEntity
  entityId    String           @db.Uuid
}

enum Sport {
  HOCKEY
}

// It may (in the future) not make sense to have this be an M2M.
model Location {
  id                     String              @id @default(uuid()) @db.Uuid
  name                   String              @unique
  description            String?
  // There needs to be a notion of who created a location so that we can use that location for suggestions to the user.
  // But there may be issues with CASCADE deletes - we will likely need to revisit.
  createdById            String              @db.Uuid
  createdBy              User                @relation("createdLocations", fields: [createdById], references: [id])
  createdAt              DateTime            @default(now())
  updatedAt              DateTime            @updatedAt
  updatedById            String              @db.Uuid
  primaryStreetAddress   String
  secondaryStreetAddress String?
  zipCode                String
  city                   String
  state                  String
  leagues                LeagueOnLocations[] @relation("leagues")
  games                  Game[]              @relation("games")
}

// Registration leagues have finite registration windows and finite start/end times.
model LeagueRegistration {
  start    DateTime
  end      DateTime
  league   League   @relation(fields: [leagueId], references: [id])
  leagueId String   @unique @db.Uuid
}

enum LeagueType {
  PICKUP
  ORGANIZED
}

enum LeagueParticipantType {
  REFEREE
  ADMIN
  PLAYER
}

model LeagueRequirements {
  minimumAge Int?
  league     League @relation(fields: [leagueId], references: [id])
  leagueId   String @unique @db.Uuid
}

model LeagueOnLocations {
  league       League   @relation("locations", fields: [leagueId], references: [id])
  leagueId     String   @db.Uuid
  location     Location @relation("leagues", fields: [locationId], references: [id])
  locationId   String   @db.Uuid
  assignedAt   DateTime @default(now())
  assignedById String

  @@id([leagueId, locationId])
}

model LeagueOnParticipants {
  league             League                  @relation("participants", fields: [leagueId], references: [id])
  leagueId           String                  @db.Uuid
  participant        User                    @relation("participatingLeagues", fields: [participantId], references: [id])
  participantId      String                  @db.Uuid
  assignedAt         DateTime                @default(now())
  assignedById       String
  participationTypes LeagueParticipantType[] @default(value: [PLAYER])

  @@id([leagueId, participantId])
}

enum LeagueCompetitionLevel {
  SOCIAL
  COMPETITIVE
  SOCIAL_COMPETITIVE
}

model League {
  id               String                 @id @default(uuid()) @db.Uuid
  name             String
  description      String?
  createdById      String                 @db.Uuid
  createdAt        DateTime               @default(now())
  updatedAt        DateTime               @updatedAt
  updatedById      String                 @db.Uuid
  registration     LeagueRegistration?
  leagueStart      DateTime?
  leagueEnd        DateTime?
  leagueType       LeagueType             @default(value: PICKUP)
  competitionLevel LeagueCompetitionLevel @default(value: SOCIAL)
  isPublic         Boolean                @default(true)
  participants     LeagueOnParticipants[] @relation("participants")
  sport            Sport
  requirements     LeagueRequirements?
  leagueGames      Game[]                 @relation("leagueGames")
  locations        LeagueOnLocations[]    @relation("locations")
  teams            Team[]                 @relation("leagueTeams")
  teamPlayers      TeamOnPlayers[]        @relation("leagueTeamPlayers")
}

enum TeamPlayerRole {
  CAPTAIN
  CO_CAPTAIN
  PLAYER
}

model TeamOnPlayers {
  team         Team           @relation("players", fields: [teamId], references: [id])
  teamId       String         @db.Uuid
  user         User           @relation("teams", fields: [userId], references: [id])
  userId       String         @db.Uuid
  role         TeamPlayerRole @default(value: PLAYER)
  // This field is added primarily to ensure that a player is only on one team per league.  However, it begs the
  // question: should we just determine the participants in a league by looking at the teams in the league?  We may need
  // to initialize a league with an empty team... and what about participants that are not players (i.e. refs, admins)?
  league       League         @relation("leagueTeamPlayers", fields: [leagueId], references: [id])
  leagueId     String         @db.Uuid
  assignedAt   DateTime       @default(now())
  assignedById String

  @@id([teamId, userId])
  @@unique([teamId, userId, leagueId])
}

enum Color {
  BLUE
  GREEN
  YELLOW
  ORANGE
  RED
  GRAY
}

model Team {
  id          String          @id @default(uuid()) @db.Uuid
  createdById String          @db.Uuid
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  updatedById String          @db.Uuid
  name        String
  color       Color           @default(value: GRAY)
  league      League          @relation("leagueTeams", fields: [leagueId], references: [id])
  leagueId    String          @db.Uuid
  players     TeamOnPlayers[] @relation("players")
  homeGames   Game[]          @relation("homeGames")
  awayGames   Game[]          @relation("awayGames")

  @@unique([name, leagueId])
}

enum GameVisitationType {
  HOME
  AWAY
}

model GameResult {
  id                       String              @id @default(uuid()) @db.Uuid
  createdById              String              @db.Uuid
  createdAt                DateTime            @default(now())
  updatedAt                DateTime            @updatedAt
  updatedById              String              @db.Uuid
  game                     Game                @relation(fields: [gameId], references: [id])
  gameId                   String              @unique @db.Uuid
  forfeitingTeamVisitation GameVisitationType?
  homeScore                Int
  awayScore                Int
}

enum GameStatus {
  PROPOSED
  CANCELLED
  POSTPONED
  // The game is not cancelled or postponed, but is not a proposal anymore.  It is either ready to be played or has been
  // played, the determination of which is made based on whether or not the Game has a result.
  FINAL
}

model Game {
  id                 String      @id @default(uuid()) @db.Uuid
  createdById        String      @db.Uuid
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt
  updatedById        String      @db.Uuid
  league             League      @relation("leagueGames", fields: [leagueId], references: [id])
  leagueId           String      @db.Uuid
  homeTeam           Team        @relation("homeGames", fields: [homeTeamId], references: [id])
  homeTeamId         String      @db.Uuid
  awayTeam           Team        @relation("awayGames", fields: [awayTeamId], references: [id])
  awayTeamId         String      @db.Uuid
  dateTime           DateTime
  location           Location?   @relation("games", fields: [locationId], references: [id])
  locationId         String?     @db.Uuid
  result             GameResult?
  cancellationReason String?
  status             GameStatus  @default(value: FINAL)
}
