generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["jsonProtocol"]
}

datasource db {
  provider = "postgresql"
  url      = env("MIGRATE_DATABASE_URL")
}

model User {
  id                   String                 @id @default(uuid()) @db.Uuid
  clerkId              String                 @unique
  firstName            String?
  lastName             String?
  profileImageUrl      String?
  // TODO: We may need to make this a required field - the only reason it is optional is because it is optional in
  // Clerk.
  emailAddress         String?
  createdAt            DateTime               @default(now())
  updatedAt            DateTime               @updatedAt
  org                  Org?                   @relation("orgUsers", fields: [orgId], references: [id])
  orgId                String?                @db.Uuid
  // Users are only created when Clerk data for the user exists - so a default value of "now" makes sense here.
  lastUpdatedFromClerk DateTime               @default(now())
  teams                TeamOnPlayers[]        @relation("teams")
  participatingLeagues LeagueOnParticipants[] @relation("participatingLeagues")
}

model Org {
  id        String   @id @default(uuid()) @db.Uuid
  clerkId   String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  timezone  String?
  name      String?
  street1   String?
  street2   String?
  city      String?
  state     String?
  zip       String?
  users     User[]   @relation("orgUsers")
}

enum Sport {
  HOCKEY
}

// It may (in the future) not make sense to have this be an M2M.
model Location {
  id                     String              @id @default(uuid()) @db.Uuid
  name                   String              @unique
  createdById            String              @db.Uuid
  createdAt              DateTime            @default(now())
  updatedAt              DateTime            @updatedAt
  updatedById            String              @db.Uuid
  primaryStreetAddress   String
  secondaryStreetAddress String?
  zipCode                String
  city                   String
  state                  String
  leagues                LeagueOnLocations[] @relation("leagues")
}

// Registration leagues have finite registration windows and finite start/end times.
model LeagueRegistration {
  start    DateTime
  end      DateTime
  league   League   @relation(fields: [leagueId], references: [id])
  leagueId String   @unique @db.Uuid
}

enum LeagueType {
  PICKUP
  ORGANIZED
}

enum LeagueParticipantType {
  REFEREE
  ADMIN
  PLAYER
}

model LeagueRequirements {
  minimumAge Int?
  league     League @relation(fields: [leagueId], references: [id])
  leagueId   String @unique @db.Uuid
}

model LeagueOnLocations {
  league       League   @relation("locations", fields: [leagueId], references: [id])
  leagueId     String   @db.Uuid
  location     Location @relation("leagues", fields: [locationId], references: [id])
  locationId   String   @db.Uuid
  assignedAt   DateTime @default(now())
  assignedById String

  @@id([leagueId, locationId])
}

model LeagueOnParticipants {
  league             League                  @relation("participants", fields: [leagueId], references: [id])
  leagueId           String                  @db.Uuid
  participant        User                    @relation("participatingLeagues", fields: [participantId], references: [id])
  participantId      String                  @db.Uuid
  assignedAt         DateTime                @default(now())
  assignedById       String
  participationTypes LeagueParticipantType[] @default(value: [PLAYER])

  @@id([leagueId, participantId])
}

enum LeagueCompetitionLevel {
  SOCIAL
  COMPETITIVE
  SOCIAL_COMPETITIVE
}

model League {
  id               String                 @id @default(uuid()) @db.Uuid
  name             String
  description      String?
  createdById      String                 @db.Uuid
  createdAt        DateTime               @default(now())
  updatedAt        DateTime               @updatedAt
  updatedById      String                 @db.Uuid
  registration     LeagueRegistration?
  leagueStart      DateTime?
  leagueEnd        DateTime?
  leagueType       LeagueType             @default(value: PICKUP)
  competitionLevel LeagueCompetitionLevel @default(value: SOCIAL)
  isPublic         Boolean                @default(true)
  participants     LeagueOnParticipants[] @relation("participants")
  sport            Sport
  requirements     LeagueRequirements?
  leagueGames      Game[]                 @relation("leagueGames")
  locations        LeagueOnLocations[]    @relation("locations")
}

model TeamOnPlayers {
  team         Team     @relation("players", fields: [teamId], references: [id])
  teamId       String   @db.Uuid
  user         User     @relation("teams", fields: [userId], references: [id])
  userId       String   @db.Uuid
  assignedAt   DateTime @default(now())
  assignedById String

  @@id([teamId, userId])
}

model Team {
  id          String          @id @default(uuid()) @db.Uuid
  createdById String          @db.Uuid
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  updatedById String          @db.Uuid
  players     TeamOnPlayers[] @relation("players")
  homeGames   Game[]          @relation("homeGames")
  awayGames   Game[]          @relation("awayGames")
}

// TODO: Scores
model Game {
  id          String   @id @default(uuid()) @db.Uuid
  createdById String   @db.Uuid
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  updatedById String   @db.Uuid
  league      League   @relation("leagueGames", fields: [leagueId], references: [id])
  leagueId    String   @db.Uuid
  // What to do about PickUp games where there is no home or away team?
  homeTeam    Team     @relation("homeGames", fields: [homeTeamId], references: [id])
  homeTeamId  String   @db.Uuid
  awayTeam    Team     @relation("awayGames", fields: [awayTeamId], references: [id])
  awayTeamId  String   @db.Uuid
  dateTime    DateTime
  location    String
}
